// Standalone single-file version of FidelityFX RCAS as a fragment shader, without any Unity render pipeline dependencies.
Shader "Hidden/TND/Upscaling/Sharpen"
{
    SubShader
    {
        Cull Off ZWrite Off ZTest Always

        Pass
        {
            Name "Sharpen"
            
            HLSLPROGRAM
            #pragma vertex VertMain
            #pragma fragment main
            #pragma target 3.5
            //#pragma enable_d3d11_debug_symbols

            #pragma multi_compile __ TND_USE_TEXARRAYS

            #include "TND_Common.hlsl"

            // Copyright  © 2023 Advanced Micro Devices, Inc.
            // Copyright  © 2024 Arm Limited.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a copy
            // of this software and associated documentation files (the "Software"), to deal
            // in the Software without restriction, including without limitation the rights
            // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            // copies of the Software, and to permit persons to whom the Software is
            // furnished to do so, subject to the following conditions:
            //
            // The above copyright notice and this permission notice shall be included in all
            // copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
            // SOFTWARE.

            #define FSR_RCAS_DENOISE 1
            #define FSR_RCAS_LIMIT (0.25-(1.0/16.0))

            uniform TEXTURE2D _MainTex;
            uniform float _Sharpness;

            float4 LoadRCAS_Input(int2 iPxPos)
            {
                return _MainTex[COORD(iPxPos)];
            }

            float Exposure() { return 1.0f; }
            float PreExposure() { return 1.0f; }

            float3 PrepareRgb(float3 fRgb, float fExposure, float fPreExposure)
            {
                fRgb /= fPreExposure;
                fRgb *= fExposure;

                fRgb = clamp(fRgb, 0.0f, 65504.0f);

                return fRgb;
            }

            float3 UnprepareRgb(float3 fRgb, float fExposure)
            {
                fRgb /= fExposure;
                fRgb *= PreExposure();

                return fRgb;
            }

            float4 FsrRcasLoadF(int2 p)
            {
                float4 fColor = LoadRCAS_Input(p);

                fColor.rgb = PrepareRgb(fColor.rgb, Exposure(), PreExposure());

                return fColor;
            }
            void FsrRcasInputF(inout float r, inout float g, inout float b) {}

            float ffxMin3(float x, float y, float z)
            {
                return min(x, min(y, z));
            }

            float ffxMax3(float x, float y, float z)
            {
                return max(x, max(y, z));
            }
            
            float ffxApproximateReciprocalMedium(float value)
            {
                float b = asfloat(uint(0x7ef19fff) - asuint(value));
                return b * (-b * value + float(2.0));
            }

            void FsrRcasF(out float pixR,  // Output values, non-vector so port between RcasFilter() and RcasFilterH() is easy.
                          out float pixG,
                          out float pixB,
                          uint2 ip,  // Integer pixel position in output.
                          float sharpness)
            {
                // Constant generated by RcasSetup().
                // Algorithm uses minimal 3x3 pixel neighborhood.
                //    b
                //  d e f
                //    h
                int2   sp = int2(ip);
                float3 b  = FsrRcasLoadF(sp + int2(0, -1)).rgb;
                float3 d  = FsrRcasLoadF(sp + int2(-1, 0)).rgb;
                float3 e = FsrRcasLoadF(sp).rgb;
                float3 f = FsrRcasLoadF(sp + int2(1, 0)).rgb;
                float3 h = FsrRcasLoadF(sp + int2(0, 1)).rgb;
                // Rename (32-bit) or regroup (16-bit).
                float bR = b.r;
                float bG = b.g;
                float bB = b.b;
                float dR = d.r;
                float dG = d.g;
                float dB = d.b;
                float eR = e.r;
                float eG = e.g;
                float eB = e.b;
                float fR = f.r;
                float fG = f.g;
                float fB = f.b;
                float hR = h.r;
                float hG = h.g;
                float hB = h.b;
                // Run optional input transform.
                FsrRcasInputF(bR, bG, bB);
                FsrRcasInputF(dR, dG, dB);
                FsrRcasInputF(eR, eG, eB);
                FsrRcasInputF(fR, fG, fB);
                FsrRcasInputF(hR, hG, hB);
                // Luma times 2.
                float bL = bB * float(0.5) + (bR * float(0.5) + bG);
                float dL = dB * float(0.5) + (dR * float(0.5) + dG);
                float eL = eB * float(0.5) + (eR * float(0.5) + eG);
                float fL = fB * float(0.5) + (fR * float(0.5) + fG);
                float hL = hB * float(0.5) + (hR * float(0.5) + hG);
                // Noise detection.
                float nz = float(0.25) * bL + float(0.25) * dL + float(0.25) * fL + float(0.25) * hL - eL;
                nz            = saturate(abs(nz) * ffxApproximateReciprocalMedium(ffxMax3(ffxMax3(bL, dL, eL), fL, hL) - ffxMin3(ffxMin3(bL, dL, eL), fL, hL)));
                nz            = float(-0.5) * nz + float(1.0);
                // Min and max of ring.
                float mn4R = min(ffxMin3(bR, dR, fR), hR);
                float mn4G = min(ffxMin3(bG, dG, fG), hG);
                float mn4B = min(ffxMin3(bB, dB, fB), hB);
                float mx4R = max(ffxMax3(bR, dR, fR), hR);
                float mx4G = max(ffxMax3(bG, dG, fG), hG);
                float mx4B = max(ffxMax3(bB, dB, fB), hB);
                // Immediate constants for peak range.
                float2 peakC = float2(1.0, -1.0 * 4.0);
                // Limiters, these need to be high precision RCPs.
                float hitMinR = mn4R * rcp(float(4.0) * mx4R);
                float hitMinG = mn4G * rcp(float(4.0) * mx4G);
                float hitMinB = mn4B * rcp(float(4.0) * mx4B);
                float hitMaxR = (peakC.x - mx4R) * rcp(float(4.0) * mn4R + peakC.y);
                float hitMaxG = (peakC.x - mx4G) * rcp(float(4.0) * mn4G + peakC.y);
                float hitMaxB = (peakC.x - mx4B) * rcp(float(4.0) * mn4B + peakC.y);
                float lobeR   = max(-hitMinR, hitMaxR);
                float lobeG   = max(-hitMinG, hitMaxG);
                float lobeB   = max(-hitMinB, hitMaxB);
                float lobe    = max(float(-FSR_RCAS_LIMIT), min(ffxMax3(lobeR, lobeG, lobeB), float(0.0))) * sharpness;
                // Apply noise removal.
            #ifdef FSR_RCAS_DENOISE
                lobe *= nz;
            #endif
                // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.
                float rcpL = ffxApproximateReciprocalMedium(float(4.0) * lobe + float(1.0));
                pixR            = (lobe * bR + lobe * dR + lobe * hR + lobe * fR + eR) * rcpL;
                pixG            = (lobe * bG + lobe * dG + lobe * hG + lobe * fG + eG) * rcpL;
                pixB            = (lobe * bB + lobe * dB + lobe * hB + lobe * fB + eB) * rcpL;
            }

            float3 CurrFilter(uint2 pos)
            {
                float3 c;
                FsrRcasF(c.r, c.g, c.b, pos, _Sharpness);
                return UnprepareRgb(c, Exposure());
            }

            float4 main(float4 SvPosition : SV_POSITION) : SV_TARGET0
            {
                uint2 uPixelCoord = uint2(SvPosition.xy);
                float3 result = CurrFilter(uPixelCoord);
                return float4(result, 1.0f);
            }
            
            ENDHLSL
        }
    }
}
